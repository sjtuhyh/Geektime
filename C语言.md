# 基础
程序是在内存中运行的，一名合格的程序员必须了解内存，学习C语言是了解内存布局的最简单、最直接、最有效的途径，C语言简直是为内存而生的，它比任何一门编程语言都贴近内存。

所有的程序都在拼尽全力节省内存，都在不遗余力提高内存使用效率，计算机的整个发展过程都在围绕内存打转，不断地优化内存布局，以保证可以同时运行多个程序。不了解内存，就学不会进程和线程，就没有资格玩中大型项目，没有资格开发底层组件，没有资格架构一个系统，命中注定你就是一个菜鸟，成不了什么气候。

C语言中的 32 个关键字：
![image](https://user-images.githubusercontent.com/34932312/78112230-83fefd80-7430-11ea-99db-32516e830dbe.png)

随着C++的流行它的语法也越来越强大，能够很完善的支持面向对象编程和泛型编程。但是一直也没有诞生出新的C++编译器，而是对原来C编译器不断扩展，让它支持C++的新特性，所以我们通常称为`C/C++编译器`，因为它同时支持C和C++，例如 Windows 下的微软编译器(cl.exe)，Linux 下的 GCC 编译器。也就是说, 你写的C、C++代码都会通过一个编译器来编译，很难说C++是一门独立的语言，还是对C的扩展。

C语言主要用于底层开发，例如：
- Windows、Linux、Unix 等操作系统的内核90%以上都使用C语言开发；
- 开发硬件驱动，让硬件和操作系统连接起来，这样用户才能使用硬件、程序员才能控制硬件；
- 单片机和嵌入式属于软硬件的结合，有很多使用C语言的地方；
- 开发系统组件或服务，用于支撑上层应用；
- 编写PHP扩展，增强PHP的功能；
- 如果对软件某个模块（例如算法和搜索部分）的效率要求较高，也可以使用C语言来开发。

计算机要处理的信息是多种多样的，如数字、文字、符号、图形、音频、视频等，这些信息在人们的眼里是不同的。但对于计算机来说，它们在内存中都是一样的，都是以二进制的形式来表示。要想学习编程，就必须了解二进制，它是计算机处理数据的基础。内存条是一个非常精密的部件，包含了上亿个电子元器件，它们很小，达到了纳米级别。这些元器件，实际上就是电路；电路的电压会变化，要么是 0V，要么是 5V，只有这两种电压。5V 是通电，用1来表示，0V 是断电，用0来表示。所以，一个元器件有2种状态，0 或者 1。

不管是运行QQ还是编辑Word文档，都是先将硬盘上的数据复制到内存，才能让CPU来处理，这个过程就叫作载入内存（Load into Memory）。完成这个过程需要一个特殊的程序（软件），这个程序就叫做加载器（Loader）。CPU直接与内存打交道，它会读取内存中的数据进行处理，并将结果保存到内存。如果需要保存到硬盘，才会将内存中的数据复制到硬盘。例如，打开Word文档，输入一些文字，虽然我们看到的不一样了，但是硬盘中的文档没有改变，新增的文字暂时保存到了内存，Ctrl+S才会保存到硬盘。因为内存断电后会丢失数据，所以如果你编辑完Word文档忘记保存就关机了，那么你将永远无法找回这些内容。

操作系统（Operating System，简称 OS）为我们解决了这个问题：当程序运行需要的空间大于内存容量时，会将内存中暂时不用的数据再写回硬盘；需要这些数据时再从硬盘中读取，并将另外一部分不用的数据写入硬盘。这样，硬盘中就会有一部分空间用来存放内存中暂时不用的数据。这一部分空间就叫做虚拟内存（Virtual Memory）。3G - 2G = 1G，上面的情况需要在硬盘上分配 1G 的虚拟内存。硬盘的读写速度比内存慢很多，反复交换数据会消耗很多时间，所以如果你的内存太小，会严重影响计算机的运行速度，甚至会出现”卡死“现象，即使CPU强劲，也不会有大的改观。如果经济条件允许，建议将内存升级为 4G，在 win7、win8、win10 下运行软件就会比较流畅了。
1个元器件称为1比特（Bit）或1位，8个元器件称为1字节（Byte），那么16个元器件就是2Byte，32个就是4Byte，以此类推：
- 8×1024个元器件就是1024Byte，简写为1KB；
- 8×1024×1024个元器件就是1024KB，简写为1MB；
- 8×1024×1024×1024个元器件就是1024MB，简写为1GB。

单位换算：
- 1Byte = 8 Bit
- 1KB = 1024Byte = 210Byte
- 1MB = 1024KB = 220Byte
- 1GB = 1024MB = 230Byte
- 1TB = 1024GB = 240Byte
- 1PB = 1024TB = 250Byte
- 1EB = 1024PB = 260Byte

总结：CPU直接从内存中读取数据，处理完成后将结果再写入内存。

![image](https://user-images.githubusercontent.com/34932312/78213555-a2730080-74e5-11ea-8b93-489b21ae41a9.png)

字符集为每个字符分配一个唯一的编号，类似于学生的学号，通过编号就能够找到对应的字符。

ASCII 编码：ASCII 的标准版本于 1967 年第一次发布，最后一次更新则是在 1986 年，迄今为止共收录了 128 个字符，包含了基本的拉丁字母（英文字母）、阿拉伯数字（也就是 1234567890）、标点符号（,.!等）、特殊符号（@#$%^&等）以及一些具有控制功能的字符（往往不会显示出来）。在 ASCII 编码中，大写字母、小写字母和阿拉伯数字都是连续分布的（见下表），这给程序设计带来了很大的方便。例如要判断一个字符是否是大写字母，就可以判断该字符的 ASCII 编码值是否在 65~90 的范围内。ASCII 编码一览表：https://baike.baidu.com/item/ASCII/309296?fr=aladdin

GB2312编码和GBK编码，将中文存储到计算机

正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是 Unicode，就像它的名字都表示的，这是一种所有符号的编码。Unicode 当然是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字严。具体的符号对应表，可以查询unicode.org，


# C语言初探
```
#include <stdio.h>
int main() 
{
    puts("huang");
    return 0;
}
```
在 Windows 下，可执行程序的后缀有.exe和.com（其中.exe比较常见）；在类 UNIX 系统（Linux、Mac OS 等）下，可执行程序没有特定的后缀，系统根据文件的头部信息来判断是否是可执行程序。例如，在屏幕上输出“VIP会员”，C语言的写法为：
```
puts("aaa");
```
二进制的写法为：
![image](https://user-images.githubusercontent.com/34932312/78223650-d526f400-74f9-11ea-9f4a-99a7fff5a260.png)

这就需要一个工具，将C语言代码转换成CPU能够识别的二进制指令，也就是将代码加工成 .exe 程序的格式；这个工具是一个特殊的软件，叫做`编译器（Compiler）`。编译器能够识别代码中的词汇、句子以及各种特定的格式，并将他们转换成计算机能够识别的二进制形式，这个过程称为编译（Compile）。编译也可以理解为“翻译”，类似于将中文翻译成英文、将英文翻译成象形文字，它是一个复杂的过程，大致包括词法分析、语法分析、语义分析、性能优化、生成可执行文件五个步骤，期间涉及到复杂的算法和硬件架构。对于学计算机或者软件的大学生，“编译原理”是一门专业课程，有兴趣的读者请自行阅读《编译原理》一书，这里我们不再展开讲解。

C语言的编译器有很多种，不同的平台下有不同的编译器，例如：
- Windows 下常用的是微软开发的 Visual C++，它被集成在 Visual Studio 中，一般不单独使用；
- Linux 下常用的是 GUN 组织开发的 GCC，很多 Linux 发行版都自带 GCC；
- Mac 下常用的是 LLVM/Clang，它被集成在 Xcode 中（Xcode 以前集成的是 GCC，后来由于 GCC 的不配合才改为 LLVM/Clang，LLVM/Clang 的性能比 GCC 更加强大）。
编译器可以 100% 保证你的代码从语法上讲是正确的，因为哪怕有一点小小的错误，编译也不能通过，编译器会告诉你哪里错了，便于你的更改。

C语言代码经过编译以后，并没有生成最终的可执行文件（.exe 文件），而是生成了一种叫做目标文件（Object File）的中间文件（或者说临时文件）。目标文件也是二进制形式的，它和可执行文件的格式是一样的。对于 Visual C++，目标文件的后缀是.obj；对于 GCC，目标文件的后缀是.o。
目标文件经过链接（Link）以后才能变成可执行文件。既然目标文件和可执行文件的格式是一样的，为什么还要再链接一次呢，直接作为可执行文件不行吗？
不行的！因为编译只是将我们自己写的代码变成了二进制形式，它还需要和系统组件（比如标准库、动态链接库等）结合起来，这些组件都是程序运行所必须的。
链接（Link）其实就是一个“打包”的过程，它将所有二进制形式的目标文件和系统组件组合成一个可执行文件。完成链接的过程也需要一个特殊的软件，叫做链接器（Linker）。

总结:不管我们编写的代码有多么简单，都必须经过「编译 --> 链接」的过程才能生成可执行文件：
- 编译就是将我们编写的源代码“翻译”成计算机可以识别的二进制格式，它们以目标文件的形式存在；
- 链接就是一个“打包”的过程，它将所有的目标文件以及系统组件组合成一个可执行文件。
一般情况下我们所说的“编译器”实际上也包括了链接器

像现在很多版本的 Linux 都默认使用 GCC 作为C语言编译器，而像 FreeBSD、macOS 等系统默认使用 LLVM Clang 编译器。由于当前 LLVM 项目主要在 Apple 的主推下发展的，所以在 macOS中，Clang 编译器又被称为 Apple LLVM 编译器。

下图展示了上述C语言编译器的分类:
![image](https://user-images.githubusercontent.com/34932312/78242530-b5e99000-7514-11ea-95f5-0ffb083d7c9a.png)

C语言自带的函数称为库函数（Library Function）, C语言自带的库称为标准库（Standard Library），其他公司或个人开发的库称为第三方库（Third-Party Library）。

引入头文件使用#include命令，并将文件名放在< >中，#include 和 < > 之间可以有空格，也可以没有。#include 命令的作用是将头文件中的文本复制到当前文件，然后和当前文件一起编译。你可以尝试将头文件中的内容复制到当前文件，那样也可以不引入头文件。

较早的C语言标准库包含了15个头文件，stdio.h 和 stdlib.h 是最常用的两个：
- stdio 是 standard input output 的缩写，stdio.h 被称为“标准输入输出文件”，包含的函数大都和输入输出有关，puts() 就是其中之一。
- stdlib 是 standard library 的缩写，stdlib.h 被称为“标准库文件”，包含的函数比较杂乱，多是一些通用工具型函数，system() 就是其中之一。

# C语言变量和数据类型
在C语言中，有多种数据类型，例如：
字符型char	短整型short	整型int	长整型long	单精度浮点型float	双精度浮点型double	无类型void

在32位环境中，各种数据类型的长度一般如下：
char 1 short 2 int 4 long 4 float 4 double 8

除了C语言，Java、C++、C#等在定义变量时也必须指明数据类型，这样的编程语言称为强类型语言。而PHP、JavaScript等在定义变量时不必指明数据类型，编译系统会自动推演，这样的编程语言称为弱类型语言。

printf 是 print format 的缩写，意思是“格式化打印”

在现代操作系统中，int 一般占用 4 个字节（Byte）的内存，共计 32 位（Bit）。如果不考虑正负数，当所有的位都为 1 时它的值最大，为 232-1 = 4,294,967,295 ≈ 43亿，这是一个很大的数，实际开发中很少用到，而诸如 1、99、12098 等较小的数使用频率反而较高。使用 4 个字节保存较小的整数绰绰有余，会空闲出两三个字节来，这些字节就白白浪费掉了，不能再被其他数据使用。现在个人电脑的内存都比较大了，配置低的也有 2G，浪费一些内存不会带来明显的损失；而在C语言被发明的早期，或者在单片机和嵌入式系统中，内存都是非常稀缺的资源，所有的程序都在尽力节省内存。

让整数占用更少的内存可以在 int 前边加 short，让整数占用更多的内存可以在 int 前边加 long，例如：
```
short int a = 10;
short int b, c = 99;
long int m = 102023;
long int n, p = 562131;
```
这样 a、b、c 只占用 2 个字节的内存，而 m、n、p 可能会占用 8 个字节的内存。也可以将 int 省略，只写 short 和 long，如下所示：
```
short a = 10;
short b, c = 99;
long m = 102023;
long n, p = 562131;
```

short、int、long 是C语言中常见的整数类型，其中 int 称为整型，short 称为短整型，long 称为长整型。

sizeof 用来获取某个数据类型或变量所占用的字节数，如果后面跟的是变量名称，那么可以省略( )，如果跟的是数据类型，就必须带上( )。

二进制数、八进制数和十六进制数的表示：
- 二进制 二进制由 0 和 1 两个数字组成，使用时必须以0b或0B（不区分大小写）开头，例如：(读者请注意，标准的C语言并不支持上面的二进制写法，只是有些编译器自己进行了扩展，才支持二进制数字。换句话说，并不是所有的编译器都支持二进制数字，只有一部分编译器支持，并且跟编译器的版本有关系。)
```
//合法的二进制
int a = 0b101;  //换算成十进制为 5
int b = -0b110010;  //换算成十进制为 -50
int c = 0B100001;  //换算成十进制为 33
//非法的二进制
int m = 101010;  //无前缀 0B，相当于十进制
int n = 0B410;  //4不是有效的二进制数字
```
- 八进制 八进制由 0~7 八个数字组成，使用时必须以0开头（注意是数字 0，不是字母 o），例如：
```
//合法的八进制数
int a = 015;  //换算成十进制为 13
int b = -0101;  //换算成十进制为 -65
int c = 0177777;  //换算成十进制为 65535
//非法的八进制
int m = 256;  //无前缀 0，相当于十进制
int n = 03A2;  //A不是有效的八进制数字
```
- 十六进制 十六进制由数字 0~9、字母 A~F 或 a~f（不区分大小写）组成，使用时必须以0x或0X（不区分大小写）开头，例如：
```
//合法的十六进制
int a = 0X2A;  //换算成十进制为 42
int b = -0XA0;  //换算成十进制为 -160
int c = 0xffff;  //换算成十进制为 65535
//非法的十六进制
int m = 5A;  //没有前缀 0X，是一个无效数字
int n = 0X3H;  //H不是有效的十六进制数字
```

C语言规定，在符号位中，用 0 表示正数，用 1 表示负数。例如 int 类型的 -10 和 +16 在内存中的表示如下：
![image](https://user-images.githubusercontent.com/34932312/78342462-e9d3bc80-75cb-11ea-860a-20f73fd2efff.png)

如果不希望设置符号位，可以在数据类型前面加上 unsigned 关键字，例如:
```
unsigned short a = 12;
unsigned int b = 1002;
unsigned long c = 9892320;
```
这样，short、int、long 中就没有符号位了，所有的位都用来表示数值，正数的取值范围更大了。这也意味着，使用了 unsigned 后只能表示正数，不能再表示负数了。如果将一个数字分为符号和数值两部分，那么不加 unsigned 的数字称为有符号数，能表示正数和负数，加了 unsigned 的数字称为无符号数，只能表示正数。

## 整数在内存中是如何存储的
原码：将一个整数转换成二进制形式，就是其原码。例如short a = 6;，a 的原码就是0000 0000 0000 0110；a 的值a = -18，此时 a 的原码就是1000 0000 0001 0010。

反码：正数和负数要区别对待，因为它们的反码不一样。对于正数，它的反码就是其原码（原码和反码相同）；负数的反码是将原码中除符号位以外的所有位（数值位）取反，也就是 0 变成 1，1 变成 0。例如short a = 6;，a 的原码和反码都是0000 0000 0000 0110；a 的值a = -18，此时 a 的反码是1111 1111 1110 1101。

补码：正数和负数的补码也不一样，也要区别对待。对于正数，它的补码就是其原码（原码、反码、补码都相同）；负数的补码是其反码加 1。例如short a = 6;，a 的原码、反码、补码都是0000 0000 0000 0110；更改 a 的值a = -18;，此时 a 的补码是1111 1111 1110 1110。

最后我们总结一下 6 和 -18 从原码到补码的转换过程：
![image](https://user-images.githubusercontent.com/34932312/78344655-471d3d00-75cf-11ea-912f-849b8d6f9ee2.png)

在计算机内存中，整数一律采用补码的形式来存储。这意味着，当读取整数时还要采用逆向的转换，也就是将补码转换为原码。将补码转换为原码也很简单：先减去 1，再将数值位取反即可。
![image](https://user-images.githubusercontent.com/34932312/78345111-f22df680-75cf-11ea-8d74-276f5ef97441.png)

## 小数在内存中的存储

## 字符串
在C语言中没有专门的字符串类型，我们只能使用数组或者指针来间接地存储字符串。两种表示形式：
```
char str1[] = "http://127.0.0.1"
char *str2 = "http://127.0.0.1"
```
str1 和 str2 是字符串的名字，后边的[ ]和前边的*是固定的写法。

字符编码：https://blog.csdn.net/guxiaonuan/article/details/78678043

字符集（Character Set）为每个字符分配了唯一的编号，在C语言中，一个字符除了可以用它的实体（也就是真正的字符）表示，还可以用编码值表示。这种使用编码值来间接地表示字符的方式称为转义字符（Escape Character）。转义字符以\或者\x开头，以\开头表示后跟八进制形式的编码值，以\x开头表示后跟十六进制形式的编码值。对于转义字符来说，只能使用八进制或者十六进制。

字符 1、2、3、a、b、c 对应的 ASCII 码的八进制形式分别是 61、62、63、141、142、143，十六进制形式分别是 31、32、33、61、62、63。下面的例子演示了转义字符的用法：
```
char a = '\61';   //字符1
char b = '\141';  //字符a
char c = '\x31';  //字符1
char d = '\x61';  //字符a
char *str1 = "\x31\x32\x33\x61\x62\x63";  //字符串"123abc"
char *str2 = "\61\62\63\141\142\143";  //字符串"123abc"
char *str3 = "The string is: \61\62\63\x61\x62\x63"  //混用八进制和十六进制形式
```
一个变量，即使不给它赋值，它也会有一个默认的初始值。因为每个变量都会占用一段内存空间，它的值就是这段内存中的数据。
```
include <stdio.h>
#include <stdlib.h>

int a1;
float b1;
char c1;

int main(){
    int a2;
    float b2;
    char c2;

    printf("a1 = %d, b1 = %f, c1 = %d\n", a1, b1, c1);
    printf("a2 = %d, b2 = %f, c2 = %d\n", a2, b2, c2);

    system("pause");
    return 0;
}
```
可能的运行结果：
```
a1 = 0, b1 = 0.000000, c1 = 0
a2 = 17969204, b2 = 23.453390, c2 = 113
```
可以发现，全局变量的默认初始值是0（它所占用的每一个字节都是0值），局部变量的默认初始值是随机的，是垃圾值，没有规律。这就告诫我们，使用局部变量之前一定要初始化，否则它的值是没有意义的。


# C语言输入输出
在C语言中，有多个函数可以从键盘获得用户输入：
```
scanf()：和 printf() 类似，scanf() 可以输入多种类型的数据。
getchar()、getche()、getch()：这三个函数都用于输入单个字符。
gets()：获取一行数据，并作为字符串处理。
```
scanf()函数:scanf 是 scan format 的缩写，意思是格式化扫描，也就是从键盘获得用户输入，和 printf 的功能正好相反。
```
#include <stdio.h>
int main()
{
    int a = 0, b = 0, c = 0, d = 0;
    scanf("%d", &a);  //输入整数并赋值给变量a
    scanf("%d", &b);  //输入整数并赋值给变量b
    printf("a+b=%d\n", a+b);  //计算a+b的值并输出
    scanf("%d %d", &c, &d);  //输入两个整数并分别赋值给c、d
    printf("c*d=%d\n", c*d);  //计算c*d的值并输出
    return 0;
}
```
在《数据在内存中的存储》一节中讲到，数据是以二进制的形式保存在内存中的，字节（Byte）是最小的可操作单位。为了便于管理，我们给每个字节分配了一个编号，使用该字节时，只要知道编号就可以，就像每个学生都有学号，老师会随机抽取学号来让学生回答问题。字节的编号是有顺序的，从 0 开始，接下来是 1、2、3……下图是 4G 内存中每个字节的编号（以十六进制表示）：
![image](https://user-images.githubusercontent.com/34932312/78871969-1a5ba080-7a7b-11ea-8ff6-87c3eddb2123.png)

这个编号，就叫做地址（Address）。int a;会在内存中分配四个字节的空间，我们将第一个字节的地址称为变量 a 的地址，也就是&a的值。对于前面讲到的整数、浮点数、字符，都要使用 & 获取它们的地址，scanf 会根据地址把读取到的数据写入内存。
```
#include <stdio.h>
int main()
{
    int a='F';
    int b=12;
    int c=452;
    printf("&a=%p, &b=%p, &c=%p\n", &a, &b, &c);
   
    return 0;
}
```

输出结果：&a=0x18ff48, &b=0x18ff44, &c=0x18ff40, %p是一个新的格式控制符，它表示以十六进制的形式（带小写的前缀）输出数据的地址。
![image](https://user-images.githubusercontent.com/34932312/78872066-44ad5e00-7a7b-11ea-8c03-d233e8674599.png)

注意：这里看到的地址都是假的，是虚拟地址，并不等于数据在物理内存中的地址。虚拟地址是现代计算机因内存管理的需要才提出的概念

## 缓冲区
缓冲区（Buffer）又称为缓存（Cache），是内存空间的一部分。也就是说，在内存中预留了一定的存储空间，用来暂时保存输入或输出的数据，这部分预留的空间就叫做缓冲区。缓冲区根据其对应的是输入设备还是输出设备，分为输入缓冲区和输出缓冲区。比如从磁盘里取信息，我们先把读出的数据放在缓冲区，计算机再直接从缓冲区中取数据，等缓冲区的数据取完后再去磁盘中读取，这样就可以减少磁盘的读写次数，再加上计算机对缓冲区的操作大大快于对磁盘的操作，故应用缓冲区可大大提高计算机的运行速度。缓冲区就是一块内存区，它用在输入输出设备和CPU之间，用来缓存数据。它使得低速的输入输出设备和高速的CPU能够协调工作，避免低速的输入输出设备占用CPU，解放出CPU，使其能够高效率工作。

缓冲区的大小，如果我们没有自己设置缓冲区的话，系统会默认为标准输入输出设置一个缓冲区，这个缓冲区的大小通常是512个字节的大小。缓冲区大小由 stdio.h 头文件中的宏 BUFSIZ 定义，如果希望查看它的大小，包含头文件，直接输出它的值即可：
```
printf("%d", BUFSIZ);
```
缓冲区的大小是可以改变的，也可以将文件关联到自定义的缓冲区

## 内存泄露
使用 malloc()、calloc()、realloc()动态分配的内存，如果在使用完毕后未释放，就会导致该内存一直被占用，直到程序结束（其实说白了就是该内存空间使用完毕之后未回收），这就是所谓的“内存泄漏”。

free() 函数的用处在于实时地回收内存，如果程序很简单，程序结束之前也不会使用过多的内存，不会降低系统的性能，那么也可以不用写 free() 函数。当程序结束后，操作系统会释放内存。但是如果在开发大型程序时不写 free() 函数，后果是很严重的。这是因为很可能在程序中要重复一万次分配10MB的内存，如果每次进行分配内存后都使用 free() 函数去释放用完的内存空间， 那么这个程序只需要使用10MB内存就可以运行。但是如果不使用 free() 函数，那么程序就要使用100GB 的内存！这其中包括绝大部分的虚拟内存，而由于虚拟内存的操作需要读写磁盘，因此，这样会极大地影响到系统的性能，系统因此可能崩溃。因此，在程序中使用 malloc() 分配内存时都对应地写出一个 free() 函数是一个良好的编程习惯。这不但体现在处理大型程序时的必要性，并能在一定程度上体现程序优美的风格和健壮性。

# C语言数组
我们知道，要想把数据放入内存，必须先要分配内存空间。放入4个整数，就得分配4个int类型的内存空间：
```
int a[4];

arrayName[index]

初始化：int a[4] = {20, 345, 700, 22};
```

二维数组定义的一般形式是：
```
dataType arrayName[length1][length2];

int a[3][4];

例如，对于数组 a[5][3]，按行分段赋值应该写作：
int a[5][3]={ {80,75,92}, {61,65,71}, {59,63,70}, {85,87,90}, {76,77,85} };

按行连续赋值应该写作：
int a[5][3]={80, 75, 92, 61, 65, 71, 59, 63, 70, 85, 87, 90, 76, 77, 85};

1) 可以只对部分元素赋值，未赋值的元素自动取“零”值。例如：
int a[3][3] = {{1}, {2}, {3}};
是对每一行的第一列元素赋值，未赋值的元素的值为 0。赋值后各元素的值为：
1  0  0
2  0  0
3  0  0
```

字符数组实际上是一系列字符的集合，也就是字符串（String）。在C语言中，没有专门的字符串变量，没有string类型，通常就用一个字符数组来存放一个字符串。C语言规定，可以将字符串直接赋值给字符数组，例如：
```
char str[30] = "c.biancheng.net";  
数组第 0 个元素为'c'，第 1 个元素为'.'，第 2 个元素为'b'，后面的元素以此类推。

为了方便，你也可以不指定数组长度，从而写作：
char str[] = "c.biancheng.net";  
```
在C语言中，字符串总是以'\0'作为结尾，所以'\0'也被称为字符串结束标志，或者字符串结束符。'\0'是 ASCII 码表中的第 0 个字符，英文称为 NUL，中文称为“空字符”。该字符既不能显示，也没有控制功能，输出该字符不会有任何效果，它在C语言中唯一的作用就是作为字符串结束标志。

字符串连接函数 strcat()
```
strcat(arrayName1, arrayName2);
```

在C语言中，数组一旦被定义后，占用的内存空间就是固定的，不能在任何位置插入元素，也不能在任何位置删除元素（当然可以修改元素），我们将这样的数组称为静态数组（Static Array）。

# 函数
C语言无参函数的定义
```
dataType  functionName(){
    //body
}
```

C语言有参函数的定义
```
dataType  functionName( dataType1 param1, dataType2 param2 ... ){
    //body
}
```

# 预处理命令
## C语言预处理命令
使用库函数之前，应该用#include引入对应的头文件。这种以#号开头的命令称为预处理命令。

C语言源文件要经过编译、链接才能生成可执行程序：
- 编译（Compile）会将源文件（.c文件）转换为目标文件。对于 VC/VS，目标文件后缀为.obj；对于GCC，目标文件后缀为.o。
- 链接（Link）是针对多个文件的，它会将编译生成的多个目标文件以及系统中的库、组件等合并成一个可执行程序。

在实际开发中，有时候在编译之前还需要对源文件进行简单的处理。例如，我们希望自己的程序在 Windows 和 Linux 下都能够运行，那么就要在 Windows 下使用 VS 编译一遍，然后在 Linux 下使用 GCC 编译一遍。但是现在有个问题，程序中要实现的某个功能在 VS 和 GCC 下使用的函数不同（假设 VS 下使用 a()，GCC 下使用 b()），VS 下的函数在 GCC 下不能编译通过，GCC 下的函数在 VS 下也不能编译通过，怎么办呢？这就需要在编译之前先对源文件进行处理：如果检测到是 VS，就保留 a() 删除 b()；如果检测到是 GCC，就保留 b() 删除 a()。这些在编译之前对源文件进行简单加工的过程，就称为预处理（即预先处理、提前处理）。

实例:假如现在要开发一个C语言程序，让它暂停 5 秒以后再输出内容，并且要求跨平台，在 Windows 和 Linux 下都能运行，怎么办呢？
这个程序的难点在于，不同平台下的暂停函数和头文件都不一样：
- Windows 平台下的暂停函数的原型是void Sleep(DWORD dwMilliseconds)（注意 S 是大写的），参数的单位是“毫秒”，位于 <windows.h> 头文件。
- Linux 平台下暂停函数的原型是unsigned int sleep (unsigned int seconds)，参数的单位是“秒”，位于 <unistd.h> 头文件。

不同的平台下必须调用不同的函数，并引入不同的头文件，否则就会导致编译错误，因为 Windows 平台下没有 sleep() 函数，也没有 <unistd.h> 头文件，反之亦然。这就要求我们在编译之前，也就是预处理阶段来解决这个问题。
```
#include <stdio.h>
//不同的平台下引入不同的头文件
#if _WIN32  //识别windows平台
#include <windows.h>
#elif __linux__  //识别linux平台
#include <unistd.h>
#endif
int main() {
    //不同的平台下调用不同的函数
    #if _WIN32  //识别windows平台
    Sleep(5000);
    #elif __linux__  //识别linux平台
    sleep(5);
    #endif
    puts("http://c.biancheng.net/");
    return 0;
}
```
#if、#elif、#endif 就是预处理命令，它们都是在编译之前由预处理程序来执行的。

# #include的用法详解
#include 的用法有两种，如下所示：
```
#include <stdHeader.h>
#include "myHeader.h"
```
使用尖括号< >和双引号" "的区别在于头文件的搜索路径不同：使用尖括号< >，编译器会到系统路径下查找头文件；而使用双引号" "，编译器首先在当前目录下查找头文件，如果没有找到，再到系统路径下查找。也就是说，使用双引号比使用尖括号多了一个查找路径，它的功能更为强大。


#include 用法举例

本例中需要创建三个文件，分别是 main.c、my.c 和 my.h，如下图所示：
![image](https://user-images.githubusercontent.com/34932312/78954909-26de0880-7b10-11ea-9765-9005569228e8.png)

my.c 所包含的代码：
```
//计算从m加到n的和
int sum(int m, int n) {
    int i, sum = 0;
    for (i = m; i <= n; i++) {
        sum += i;
    }
    return sum;
}
```

my.h 所包含的代码：
```
//声明函数
int sum(int m, int n);
```

main.c 所包含的代码：
```
#include <stdio.h>
#include "my.h"
int main() {
    printf("%d\n", sum(1, 100));
    return 0;
}
```
我们在 my.c 中定义了 sum() 函数，在 my.h 中声明了 sum() 函数。

在头文件中定义定义函数和全局变量」这种认知是原则性的错误！不管是标准头文件，还是自定义头文件，都只能包含变量和函数的声明，不能包含定义，否则在多次引入时会引起重复定义错误。

## C语言宏定义
#define 叫做宏定义命令，它也是C语言预处理命令的一种。所谓宏定义，就是用一个标识符来表示一个字符串，如果在后面的代码中出现了该标识符，那么就全部替换成指定的字符串。
```
#include <stdio.h>
#define N 100
int main(){
    int sum = 20 + N;
    printf("%d\n", sum);
    return 0;
}
```

宏定义的一般形式为：
```
#define  宏名  字符串
```

## C语言中几个预定义宏
顾名思义，预定义宏就是已经预先定义好的宏，我们可以直接使用，无需再重新定义。

ANSI C 规定了以下几个预定义宏，它们在各个编译器下都可以使用：
- __LINE__：表示当前源代码的行号；
- __FILE__：表示当前源文件的名称；
- __DATE__：表示当前的编译日期；
- __TIME__：表示当前的编译时间；
- __STDC__：当要求程序严格遵循ANSI C标准时该标识被赋值为1；
- __cplusplus：当编写C++程序时该标识符被定义。

预定义宏演示：
```
#include <stdio.h>
#include <stdlib.h>

int main() {
    printf("Date : %s\n", __DATE__);
    printf("Time : %s\n", __TIME__);
    printf("File : %s\n", __FILE__);
    printf("Line : %d\n", __LINE__);

    system("pause");
    return 0;
}
```

## #if、##ifdef、#ifndef的用法详解，C语言条件编译

## 总结
![image](https://user-images.githubusercontent.com/34932312/78955544-221a5400-7b12-11ea-82b2-fbe06aa38881.png)

# 指针
我们将内存中字节的编号称为地址（Address）或指针（Pointer）。地址从 0 开始依次增加，对于 32 位环境，程序能够使用的内存为 4GB，最小的地址为 0，最大的地址为 0XFFFFFFFF。

数据和代码都以二进制的形式存储在内存中，计算机无法从格式上区分某块内存到底存储的是数据还是代码。当程序被加载到内存后，操作系统会给不同的内存块指定不同的权限，拥有读取和执行权限的内存块就是代码，而拥有读取和写入权限（也可能只有读取权限）的内存块就是数据。

CPU访问内存时需要的是地址，而不是变量名和函数名！变量名和函数名只是地址的一种助记符，当源文件被编译和链接成可执行程序后，它们都会被替换成地址。编译和链接过程的一项重要任务就是找到这些名称所对应的地址。

假设变量 a、b、c 在内存中的地址分别是 0X1000、0X2000、0X3000，那么加法运算c = a + b;将会被转换成类似下面的形式：
```
0X3000 = (0X1000) + (0X2000);
```
( )表示取值操作，整个表达式的意思是，取出地址 0X1000 和 0X2000 上的值，将它们相加，把相加的结果赋值给地址为 0X3000 的内存

## 指针变量
数据在内存中的地址也称为指针，如果一个变量存储了一份数据的指针，我们就称它为指针变量。

现在假设有一个 char 类型的变量 c，它存储了字符 'K'（ASCII码为十进制数 75），并占用了地址为 0X11A 的内存（地址通常用十六进制表示）。另外有一个指针变量 p，它的值为 0X11A，正好等于变量 c 的地址，这种情况我们就称 p 指向了 c，或者说 p 是指向变量 c 的指针。
![image](https://user-images.githubusercontent.com/34932312/78955867-272bd300-7b13-11ea-9819-e5150f5319b9.png)

定义指针变量
定义指针变量与定义普通变量非常类似，不过要在变量名前面加星号*，格式为：
```
datatype *name;
```

*表示这是一个指针变量，datatype表示该指针变量所指向的数据的类型 。例如：
```
int *p1;
```

p1 是一个指向 int 类型数据的指针变量，至于 p1 究竟指向哪一份数据，应该由赋予它的值决定。再如：
```
int a = 100;
int *p_a = &a;
```
在定义指针变量 p_a 的同时对它进行初始化，并将变量 a 的地址赋予它，此时 p_a 就指向了 a。值得注意的是，p_a 需要的一个地址，a 前面必须要加取地址符&，否则是不对的。

和普通变量一样，指针变量也可以被多次写入，只要你想，随时都能够改变指针变量的值，请看下面的代码：
```
//定义普通变量
float a = 99.5, b = 10.6;
char c = '@', d = '#';
//定义指针变量
float *p1 = &a;
char *p2 = &c;
//修改指针变量的值
p1 = &b;
p2 = &d;
```
*是一个特殊符号，表明一个变量是指针变量，定义 p1、p2 时必须带*。而给 p1、p2 赋值时，因为已经知道了它是一个指针变量，就没必要多此一举再带上*，后边可以像使用普通变量一样来使用指针变量。也就是说，定义指针变量时必须带*，给指针变量赋值时不能带*。

假设变量 a、b、c、d 的地址分别为 0X1000、0X1004、0X2000、0X2004，下面的示意图很好地反映了 p1、p2 指向的变化：
![image](https://user-images.githubusercontent.com/34932312/78956263-5262f200-7b14-11ea-962b-cfd1aec65932.png)
需要强调的是，p1、p2 的类型分别是float*和char*，而不是float和char，它们是完全不同的数据类型，读者要引起注意。

指针变量也可以连续定义，例如：
```
int *a, *b, *c;  //a、b、c 的类型都是 int*
```
注意每个变量前面都要带*。如果写成下面的形式，那么只有 a 是指针变量，b、c 都是类型为 int 的普通变量：
```
int *a, b, c;
```

## C语言指针变量的运算
指针变量保存的是地址，而地址本质上是一个整数，所以指针变量可以进行部分运算，例如加法、减法、比较等，请看下面的代码：
```
#include <stdio.h>

int main(){
    int    a = 10,   *pa = &a, *paa = &a;
    double b = 99.9, *pb = &b;
    char   c = '@',  *pc = &c;
    //最初的值
    printf("&a=%#X, &b=%#X, &c=%#X\n", &a, &b, &c);
    printf("pa=%#X, pb=%#X, pc=%#X\n", pa, pb, pc);
    //加法运算
    pa++; pb++; pc++;
    printf("pa=%#X, pb=%#X, pc=%#X\n", pa, pb, pc);
    //减法运算
    pa -= 2; pb -= 2; pc -= 2;
    printf("pa=%#X, pb=%#X, pc=%#X\n", pa, pb, pc);
    //比较运算
    if(pa == paa){
        printf("%d\n", *paa);
    }else{
        printf("%d\n", *pa);
    }
    return 0;
}
```
运行结果：
```
&a=0X28FF44, &b=0X28FF30, &c=0X28FF2B
pa=0X28FF44, pb=0X28FF30, pc=0X28FF2B
pa=0X28FF48, pb=0X28FF38, pc=0X28FF2C
pa=0X28FF40, pb=0X28FF28, pc=0X28FF2A
2686784
```
从运算结果可以看出：pa、pb、pc 每次加 1，它们的地址分别增加 4、8、1，正好是 int、double、char 类型的长度；减 2 时，地址分别减少 8、16、2，正好是 int、double、char 类型长度的 2 倍。

## 数组指针
定义数组时，要给出数组名和数组长度，数组名可以认为是一个指针，它指向数组的第 0 个元素。在C语言中，我们将第 0 个元素的地址称为数组的首地址。

下面的例子演示了如何以指针的方式遍历数组元素：
```
#include <stdio.h>
int main(){
    int arr[] = { 99, 15, 100, 888, 252 };
    int len = sizeof(arr) / sizeof(int);  //求数组长度
    int i;
    for(i=0; i<len; i++){
        printf("%d  ", *(arr+i) );  //*(arr+i)等价于arr[i]
    }
    printf("\n");
    return 0;
}
```

如果一个指针指向了数组，我们就称它为数组指针（Array Pointer）。

数组指针指向的是数组中的一个具体元素，而不是整个数组，所以数组指针的类型和数组元素的类型有关，上面的例子中，p 指向的数组元素是 int 类型，所以 p 的类型必须也是int *。
```
int arr[] = { 99, 15, 100, 888, 252 };
int *p = arr;
```

```
char str[] = "http://c.biancheng.net";

字符串指针, C语言还支持另外一种表示字符串的方法，就是直接使用一个指针指向字符串
char *str = "http://c.biancheng.net";
```
字符串中的所有字符在内存中是连续排列的，str 指向的是字符串的第 0 个字符；我们通常将第 0  个字符的地址称为字符串的首地址。字符串中每个字符的类型都是char，所以 str 的类型也必须是char *。

```
#include <stdio.h>
#include <string.h>
int main(){
    char *str = "http://c.biancheng.net";
    int len = strlen(str), i;
   
    //直接输出字符串
    printf("%s\n", str);
    //使用*(str+i)
    for(i=0; i<len; i++){
        printf("%c", *(str+i));
    }
    printf("\n");
    //使用str[i]
    for(i=0; i<len; i++){
        printf("%c", str[i]);
    }
    printf("\n");
    return 0;
}
```

运行结果：
http://c.biancheng.net
http://c.biancheng.net
http://c.biancheng.net

这一切看起来和字符数组是多么地相似，它们都可以使用%s输出整个字符串，都可以使用*或[ ]获取单个字符，这两种表示字符串的方式是不是就没有区别了呢？

有！它们最根本的区别是在内存中的存储区域不一样，字符数组存储在全局数据区或栈区，第二种形式的字符串存储在常量区。全局数据区和栈区的字符串（也包括其他数据）有读取和写入的权限，而常量区的字符串（也包括其他数据）只有读取权限，没有写入权限。

## 指针变量作为函数参数
http://c.biancheng.net/view/2014.html

## 二级指针

指针可以指向一份普通类型的数据，例如 int、double、char 等，也可以指向一份指针类型的数据，例如 int *、double *、char * 等。

如果一个指针指向的是另外一个指针，我们就称它为二级指针，或者指向指针的指针。

假设有一个 int 类型的变量 a，p1是指向 a 的指针变量，p2 又是指向 p1 的指针变量

```
int a =100;
int *p1 = &a;
int **p2 = &p1;
```


## 空指针NULL
在C语言中，如果一个指针不指向任何数据，我们就称之为空指针，用NULL表示。例如：
```
int *p = NULL;
```
注意区分大小写，null 没有任何特殊含义，只是一个普通的标识符。

NULL 是一个宏定义，在stdio.h被定义为：
```
#define NULL ((void *)0)
```
(void *)0表示把数值 0 强制转换为void *类型，最外层的( )把宏定义的内容括起来，我们自己进行宏定义时也推荐这么做，防止发生歧义。

## void 指针
C语言还有一种void指针类型，即可以定义一个指针变量，但不说明它指向哪一种类型数据。例如：
```
void *p = malloc(2);
```
在内存中分配2个字节的空间，但不确定它保存什么类型的数据。

注意，void 指针与空指针 NULL 不同：NULL 说明指针不指向任何数据，是“空的”；而 void 指针实实在在地指向一块内存，只是不知道这块内存中是什么类型的数据。
