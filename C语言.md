# 基础
程序是在内存中运行的，一名合格的程序员必须了解内存，学习C语言是了解内存布局的最简单、最直接、最有效的途径，C语言简直是为内存而生的，它比任何一门编程语言都贴近内存。

所有的程序都在拼尽全力节省内存，都在不遗余力提高内存使用效率，计算机的整个发展过程都在围绕内存打转，不断地优化内存布局，以保证可以同时运行多个程序。不了解内存，就学不会进程和线程，就没有资格玩中大型项目，没有资格开发底层组件，没有资格架构一个系统，命中注定你就是一个菜鸟，成不了什么气候。

C语言中的 32 个关键字：
![image](https://user-images.githubusercontent.com/34932312/78112230-83fefd80-7430-11ea-99db-32516e830dbe.png)

随着C++的流行它的语法也越来越强大，能够很完善的支持面向对象编程和泛型编程。但是一直也没有诞生出新的C++编译器，而是对原来C编译器不断扩展，让它支持C++的新特性，所以我们通常称为`C/C++编译器`，因为它同时支持C和C++，例如 Windows 下的微软编译器(cl.exe)，Linux 下的 GCC 编译器。也就是说, 你写的C、C++代码都会通过一个编译器来编译，很难说C++是一门独立的语言，还是对C的扩展。

C语言主要用于底层开发，例如：
- Windows、Linux、Unix 等操作系统的内核90%以上都使用C语言开发；
- 开发硬件驱动，让硬件和操作系统连接起来，这样用户才能使用硬件、程序员才能控制硬件；
- 单片机和嵌入式属于软硬件的结合，有很多使用C语言的地方；
- 开发系统组件或服务，用于支撑上层应用；
- 编写PHP扩展，增强PHP的功能；
- 如果对软件某个模块（例如算法和搜索部分）的效率要求较高，也可以使用C语言来开发。

计算机要处理的信息是多种多样的，如数字、文字、符号、图形、音频、视频等，这些信息在人们的眼里是不同的。但对于计算机来说，它们在内存中都是一样的，都是以二进制的形式来表示。要想学习编程，就必须了解二进制，它是计算机处理数据的基础。内存条是一个非常精密的部件，包含了上亿个电子元器件，它们很小，达到了纳米级别。这些元器件，实际上就是电路；电路的电压会变化，要么是 0V，要么是 5V，只有这两种电压。5V 是通电，用1来表示，0V 是断电，用0来表示。所以，一个元器件有2种状态，0 或者 1。

不管是运行QQ还是编辑Word文档，都是先将硬盘上的数据复制到内存，才能让CPU来处理，这个过程就叫作载入内存（Load into Memory）。完成这个过程需要一个特殊的程序（软件），这个程序就叫做加载器（Loader）。CPU直接与内存打交道，它会读取内存中的数据进行处理，并将结果保存到内存。如果需要保存到硬盘，才会将内存中的数据复制到硬盘。例如，打开Word文档，输入一些文字，虽然我们看到的不一样了，但是硬盘中的文档没有改变，新增的文字暂时保存到了内存，Ctrl+S才会保存到硬盘。因为内存断电后会丢失数据，所以如果你编辑完Word文档忘记保存就关机了，那么你将永远无法找回这些内容。

操作系统（Operating System，简称 OS）为我们解决了这个问题：当程序运行需要的空间大于内存容量时，会将内存中暂时不用的数据再写回硬盘；需要这些数据时再从硬盘中读取，并将另外一部分不用的数据写入硬盘。这样，硬盘中就会有一部分空间用来存放内存中暂时不用的数据。这一部分空间就叫做虚拟内存（Virtual Memory）。3G - 2G = 1G，上面的情况需要在硬盘上分配 1G 的虚拟内存。硬盘的读写速度比内存慢很多，反复交换数据会消耗很多时间，所以如果你的内存太小，会严重影响计算机的运行速度，甚至会出现”卡死“现象，即使CPU强劲，也不会有大的改观。如果经济条件允许，建议将内存升级为 4G，在 win7、win8、win10 下运行软件就会比较流畅了。
1个元器件称为1比特（Bit）或1位，8个元器件称为1字节（Byte），那么16个元器件就是2Byte，32个就是4Byte，以此类推：
- 8×1024个元器件就是1024Byte，简写为1KB；
- 8×1024×1024个元器件就是1024KB，简写为1MB；
- 8×1024×1024×1024个元器件就是1024MB，简写为1GB。

单位换算：
- 1Byte = 8 Bit
- 1KB = 1024Byte = 210Byte
- 1MB = 1024KB = 220Byte
- 1GB = 1024MB = 230Byte
- 1TB = 1024GB = 240Byte
- 1PB = 1024TB = 250Byte
- 1EB = 1024PB = 260Byte

总结：CPU直接从内存中读取数据，处理完成后将结果再写入内存。

![image](https://user-images.githubusercontent.com/34932312/78213555-a2730080-74e5-11ea-8b93-489b21ae41a9.png)

字符集为每个字符分配一个唯一的编号，类似于学生的学号，通过编号就能够找到对应的字符。

ASCII 编码：ASCII 的标准版本于 1967 年第一次发布，最后一次更新则是在 1986 年，迄今为止共收录了 128 个字符，包含了基本的拉丁字母（英文字母）、阿拉伯数字（也就是 1234567890）、标点符号（,.!等）、特殊符号（@#$%^&等）以及一些具有控制功能的字符（往往不会显示出来）。在 ASCII 编码中，大写字母、小写字母和阿拉伯数字都是连续分布的（见下表），这给程序设计带来了很大的方便。例如要判断一个字符是否是大写字母，就可以判断该字符的 ASCII 编码值是否在 65~90 的范围内。ASCII 编码一览表：https://baike.baidu.com/item/ASCII/309296?fr=aladdin

GB2312编码和GBK编码，将中文存储到计算机

正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是 Unicode，就像它的名字都表示的，这是一种所有符号的编码。Unicode 当然是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字严。具体的符号对应表，可以查询unicode.org，


# C语言初探
```
#include <stdio.h>
int main() 
{
    puts("huang");
    return 0;
}
```
在 Windows 下，可执行程序的后缀有.exe和.com（其中.exe比较常见）；在类 UNIX 系统（Linux、Mac OS 等）下，可执行程序没有特定的后缀，系统根据文件的头部信息来判断是否是可执行程序。例如，在屏幕上输出“VIP会员”，C语言的写法为：
```
puts("VIP会员");
```
二进制的写法为：
![image](https://user-images.githubusercontent.com/34932312/78223650-d526f400-74f9-11ea-9f4a-99a7fff5a260.png)

这就需要一个工具，将C语言代码转换成CPU能够识别的二进制指令，也就是将代码加工成 .exe 程序的格式；这个工具是一个特殊的软件，叫做`编译器（Compiler）`。编译器能够识别代码中的词汇、句子以及各种特定的格式，并将他们转换成计算机能够识别的二进制形式，这个过程称为编译（Compile）。编译也可以理解为“翻译”，类似于将中文翻译成英文、将英文翻译成象形文字，它是一个复杂的过程，大致包括词法分析、语法分析、语义分析、性能优化、生成可执行文件五个步骤，期间涉及到复杂的算法和硬件架构。对于学计算机或者软件的大学生，“编译原理”是一门专业课程，有兴趣的读者请自行阅读《编译原理》一书，这里我们不再展开讲解。

C语言的编译器有很多种，不同的平台下有不同的编译器，例如：
- Windows 下常用的是微软开发的 Visual C++，它被集成在 Visual Studio 中，一般不单独使用；
- Linux 下常用的是 GUN 组织开发的 GCC，很多 Linux 发行版都自带 GCC；
- Mac 下常用的是 LLVM/Clang，它被集成在 Xcode 中（Xcode 以前集成的是 GCC，后来由于 GCC 的不配合才改为 LLVM/Clang，LLVM/Clang 的性能比 GCC 更加强大）。
编译器可以 100% 保证你的代码从语法上讲是正确的，因为哪怕有一点小小的错误，编译也不能通过，编译器会告诉你哪里错了，便于你的更改。

C语言代码经过编译以后，并没有生成最终的可执行文件（.exe 文件），而是生成了一种叫做目标文件（Object File）的中间文件（或者说临时文件）。目标文件也是二进制形式的，它和可执行文件的格式是一样的。对于 Visual C++，目标文件的后缀是.obj；对于 GCC，目标文件的后缀是.o。
目标文件经过链接（Link）以后才能变成可执行文件。既然目标文件和可执行文件的格式是一样的，为什么还要再链接一次呢，直接作为可执行文件不行吗？
不行的！因为编译只是将我们自己写的代码变成了二进制形式，它还需要和系统组件（比如标准库、动态链接库等）结合起来，这些组件都是程序运行所必须的。
链接（Link）其实就是一个“打包”的过程，它将所有二进制形式的目标文件和系统组件组合成一个可执行文件。完成链接的过程也需要一个特殊的软件，叫做链接器（Linker）。

总结:不管我们编写的代码有多么简单，都必须经过「编译 --> 链接」的过程才能生成可执行文件：
- 编译就是将我们编写的源代码“翻译”成计算机可以识别的二进制格式，它们以目标文件的形式存在；
- 链接就是一个“打包”的过程，它将所有的目标文件以及系统组件组合成一个可执行文件。
一般情况下我们所说的“编译器”实际上也包括了链接器

像现在很多版本的 Linux 都默认使用 GCC 作为C语言编译器，而像 FreeBSD、macOS 等系统默认使用 LLVM Clang 编译器。由于当前 LLVM 项目主要在 Apple 的主推下发展的，所以在 macOS中，Clang 编译器又被称为 Apple LLVM 编译器。

下图展示了上述C语言编译器的分类:
![image](https://user-images.githubusercontent.com/34932312/78242530-b5e99000-7514-11ea-95f5-0ffb083d7c9a.png)

C语言自带的函数称为库函数（Library Function）, C语言自带的库称为标准库（Standard Library），其他公司或个人开发的库称为第三方库（Third-Party Library）。

引入头文件使用#include命令，并将文件名放在< >中，#include 和 < > 之间可以有空格，也可以没有。#include 命令的作用是将头文件中的文本复制到当前文件，然后和当前文件一起编译。你可以尝试将头文件中的内容复制到当前文件，那样也可以不引入头文件。

较早的C语言标准库包含了15个头文件，stdio.h 和 stdlib.h 是最常用的两个：
- stdio 是 standard input output 的缩写，stdio.h 被称为“标准输入输出文件”，包含的函数大都和输入输出有关，puts() 就是其中之一。
- stdlib 是 standard library 的缩写，stdlib.h 被称为“标准库文件”，包含的函数比较杂乱，多是一些通用工具型函数，system() 就是其中之一。

# C语言变量和数据类型
在C语言中，有多种数据类型，例如：
字符型char	短整型short	整型int	长整型long	单精度浮点型float	双精度浮点型double	无类型void

在32位环境中，各种数据类型的长度一般如下：
char 1 short 2 int 4 long 4 float 4 double 8

除了C语言，Java、C++、C#等在定义变量时也必须指明数据类型，这样的编程语言称为强类型语言。而PHP、JavaScript等在定义变量时不必指明数据类型，编译系统会自动推演，这样的编程语言称为弱类型语言。

printf 是 print format 的缩写，意思是“格式化打印”

在现代操作系统中，int 一般占用 4 个字节（Byte）的内存，共计 32 位（Bit）。如果不考虑正负数，当所有的位都为 1 时它的值最大，为 232-1 = 4,294,967,295 ≈ 43亿，这是一个很大的数，实际开发中很少用到，而诸如 1、99、12098 等较小的数使用频率反而较高。使用 4 个字节保存较小的整数绰绰有余，会空闲出两三个字节来，这些字节就白白浪费掉了，不能再被其他数据使用。现在个人电脑的内存都比较大了，配置低的也有 2G，浪费一些内存不会带来明显的损失；而在C语言被发明的早期，或者在单片机和嵌入式系统中，内存都是非常稀缺的资源，所有的程序都在尽力节省内存。

让整数占用更少的内存可以在 int 前边加 short，让整数占用更多的内存可以在 int 前边加 long，例如：
```
short int a = 10;
short int b, c = 99;
long int m = 102023;
long int n, p = 562131;
```
这样 a、b、c 只占用 2 个字节的内存，而 m、n、p 可能会占用 8 个字节的内存。也可以将 int 省略，只写 short 和 long，如下所示：
```
short a = 10;
short b, c = 99;
long m = 102023;
long n, p = 562131;
```

short、int、long 是C语言中常见的整数类型，其中 int 称为整型，short 称为短整型，long 称为长整型。

sizeof 用来获取某个数据类型或变量所占用的字节数，如果后面跟的是变量名称，那么可以省略( )，如果跟的是数据类型，就必须带上( )。

二进制数、八进制数和十六进制数的表示：
- 二进制 二进制由 0 和 1 两个数字组成，使用时必须以0b或0B（不区分大小写）开头，例如：(读者请注意，标准的C语言并不支持上面的二进制写法，只是有些编译器自己进行了扩展，才支持二进制数字。换句话说，并不是所有的编译器都支持二进制数字，只有一部分编译器支持，并且跟编译器的版本有关系。)
```
//合法的二进制
int a = 0b101;  //换算成十进制为 5
int b = -0b110010;  //换算成十进制为 -50
int c = 0B100001;  //换算成十进制为 33
//非法的二进制
int m = 101010;  //无前缀 0B，相当于十进制
int n = 0B410;  //4不是有效的二进制数字
```
- 八进制 八进制由 0~7 八个数字组成，使用时必须以0开头（注意是数字 0，不是字母 o），例如：
```
//合法的八进制数
int a = 015;  //换算成十进制为 13
int b = -0101;  //换算成十进制为 -65
int c = 0177777;  //换算成十进制为 65535
//非法的八进制
int m = 256;  //无前缀 0，相当于十进制
int n = 03A2;  //A不是有效的八进制数字
```
- 十六进制 十六进制由数字 0~9、字母 A~F 或 a~f（不区分大小写）组成，使用时必须以0x或0X（不区分大小写）开头，例如：
```
//合法的十六进制
int a = 0X2A;  //换算成十进制为 42
int b = -0XA0;  //换算成十进制为 -160
int c = 0xffff;  //换算成十进制为 65535
//非法的十六进制
int m = 5A;  //没有前缀 0X，是一个无效数字
int n = 0X3H;  //H不是有效的十六进制数字
```

C语言规定，在符号位中，用 0 表示正数，用 1 表示负数。例如 int 类型的 -10 和 +16 在内存中的表示如下：
![image](https://user-images.githubusercontent.com/34932312/78342462-e9d3bc80-75cb-11ea-860a-20f73fd2efff.png)

如果不希望设置符号位，可以在数据类型前面加上 unsigned 关键字，例如:
```
unsigned short a = 12;
unsigned int b = 1002;
unsigned long c = 9892320;
```
这样，short、int、long 中就没有符号位了，所有的位都用来表示数值，正数的取值范围更大了。这也意味着，使用了 unsigned 后只能表示正数，不能再表示负数了。如果将一个数字分为符号和数值两部分，那么不加 unsigned 的数字称为有符号数，能表示正数和负数，加了 unsigned 的数字称为无符号数，只能表示正数。

## 整数在内存中是如何存储的
原码：将一个整数转换成二进制形式，就是其原码。例如short a = 6;，a 的原码就是0000 0000 0000 0110；a 的值a = -18，此时 a 的原码就是1000 0000 0001 0010。

反码：正数和负数要区别对待，因为它们的反码不一样。对于正数，它的反码就是其原码（原码和反码相同）；负数的反码是将原码中除符号位以外的所有位（数值位）取反，也就是 0 变成 1，1 变成 0。例如short a = 6;，a 的原码和反码都是0000 0000 0000 0110；a 的值a = -18，此时 a 的反码是1111 1111 1110 1101。

补码：正数和负数的补码也不一样，也要区别对待。对于正数，它的补码就是其原码（原码、反码、补码都相同）；负数的补码是其反码加 1。例如short a = 6;，a 的原码、反码、补码都是0000 0000 0000 0110；更改 a 的值a = -18;，此时 a 的补码是1111 1111 1110 1110。

最后我们总结一下 6 和 -18 从原码到补码的转换过程：
![image](https://user-images.githubusercontent.com/34932312/78344655-471d3d00-75cf-11ea-912f-849b8d6f9ee2.png)

在计算机内存中，整数一律采用补码的形式来存储。这意味着，当读取整数时还要采用逆向的转换，也就是将补码转换为原码。将补码转换为原码也很简单：先减去 1，再将数值位取反即可。
![image](https://user-images.githubusercontent.com/34932312/78345111-f22df680-75cf-11ea-8d74-276f5ef97441.png)

## 小数在内存中的存储

















































						






















